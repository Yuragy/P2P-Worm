#define _GNU_SOURCE

#include "exploit_db.h"
#include "util.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>  

static void push_exploit(exploit_db_t *db,
                         const char *id,
                         const char *cve,
                         const char *desc,
                         const char *path)
{
    exploit_item_t *tmp = realloc(db->items, (db->count + 1) * sizeof(*tmp));
    if (!tmp) return;          // OOM: skip
    db->items = tmp;

    db->items[db->count].id   = strdup(id   ? id   : "");
    db->items[db->count].cve  = strdup(cve  ? cve  : "");
    db->items[db->count].desc = strdup(desc ? desc : "");
    db->items[db->count].path = strdup(path ? path : "");
    db->count++;
}

static int parse_csv_line(const char *line,
                          char **id, char **cve, char **desc, char **path)
{
    size_t cnt = 0;
    char **cols = str_split(line, ',', &cnt);
    if (cnt < 4) {
        free_strv(cols, cnt);
        return -1;
    }
    for (size_t i = 0; i < 4; i++) cols[i] = str_trim(cols[i]);

    *id   = strdup(cols[0]);
    *cve  = strdup(cols[1]);
    *desc = strdup(cols[2]);
    *path = strdup(cols[3]);

    free_strv(cols, cnt);
    return 0;
}

int exploit_db_load(exploit_db_t *db, const char *csv_path) {
    if (!db || !csv_path) return -1;
    db->items = NULL;
    db->count = 0;

    FILE *f = fopen(csv_path, "r");
    if (!f) {
        perror("exploit_db_load fopen");
        return -1;
    }

    char *line = NULL;
    size_t cap = 0;
    ssize_t nread;

    while ((nread = getline(&line, &cap, f)) != -1) {
        char *p = str_trim(line);
        if (*p == '\0' || *p == '#') continue;

        char *id = NULL, *cve = NULL, *desc = NULL, *path = NULL;
        if (parse_csv_line(p, &id, &cve, &desc, &path) == 0) {
            push_exploit(db, id, cve, desc, path);
        }
        free(id); free(cve); free(desc); free(path);
    }

    free(line);
    fclose(f);
    return 0;
}

void exploit_db_free(exploit_db_t *db) {
    if (!db || !db->items) return;
    for (size_t i = 0; i < db->count; i++) {
        free(db->items[i].id);
        free(db->items[i].cve);
        free(db->items[i].desc);
        free(db->items[i].path);
    }
    free(db->items);
    db->items = NULL;
    db->count = 0;
}

void exploit_db_print_for_cves(const exploit_db_t *db, const cve_list_t *cves) {
    if (!db || !cves) return;

    for (size_t i = 0; i < cves->count; i++) {
        const char *cve = cves->items[i].id;
        int header_printed = 0;

        for (size_t j = 0; j < db->count; j++) {
            if (strcasecmp(db->items[j].cve, cve) == 0) {
                if (!header_printed) {
                    printf("-> Exploits for %s:\n", cve);
                    header_printed = 1;
                }
                printf("   [%s] %s -> %s\n",
                       db->items[j].id,
                       db->items[j].desc,
                       db->items[j].path);
            }
        }
    }
}
